# ðŸ”„ Offline-First System with Cloud Sync

## Overview
Transform your system into an offline-capable application that:
- âœ… Works without internet connection
- âœ… Stores data locally using IndexedDB
- âœ… Syncs automatically when online
- âœ… Handles conflicts intelligently
- âœ… Shows sync status to users

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           User Interface (PWA)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      Service Worker (Offline Support)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     IndexedDB (Local Storage)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Sync Manager (Background Sync)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Django REST API (Server/Cloud)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     PostgreSQL/MySQL (Database)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Implementation Strategy

### Phase 1: Convert to REST API
### Phase 2: Implement Service Workers
### Phase 3: Add IndexedDB Storage
### Phase 4: Create Sync Manager
### Phase 5: Handle Conflicts

---

## Phase 1: Convert Django to REST API

### Step 1: Install Django REST Framework

```bash
pip install djangorestframework
pip install django-cors-headers
```

### Step 2: Update settings.py

```python
INSTALLED_APPS = [
    # ... existing apps
    'rest_framework',
    'corsheaders',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # Add at top
    # ... existing middleware
]

# CORS Settings (for development)
CORS_ALLOW_ALL_ORIGINS = True  # Change in production

# REST Framework Settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.TokenAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}
```

### Step 3: Create Serializers

```python
# serializers.py
from rest_framework import serializers
from .models import Bidhaas, Sale, SaleItem, Customer

class BidhaaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Bidhaas
        fields = '__all__'

class SaleItemSerializer(serializers.ModelSerializer):
    bidhaa_name = serializers.CharField(source='bidhaa.jina', read_only=True)
    
    class Meta:
        model = SaleItem
        fields = '__all__'

class SaleSerializer(serializers.ModelSerializer):
    items = SaleItemSerializer(many=True, read_only=True)
    sold_by_username = serializers.CharField(source='sold_by.username', read_only=True)
    
    class Meta:
        model = Sale
        fields = '__all__'

class CustomerSerializer(serializers.ModelSerializer):
    class Meta:
        model = Customer
        fields = '__all__'
```

### Step 4: Create API Views

```python
# api_views.py
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.utils import timezone

class BidhaaViewSet(viewsets.ModelViewSet):
    queryset = Bidhaas.objects.all()
    serializer_class = BidhaaSerializer
    
    @action(detail=False, methods=['get'])
    def sync(self, request):
        """Get all items modified after a timestamp"""
        last_sync = request.query_params.get('last_sync')
        if last_sync:
            queryset = self.queryset.filter(updated_at__gt=last_sync)
        else:
            queryset = self.queryset.all()
        
        serializer = self.get_serializer(queryset, many=True)
        return Response({
            'data': serializer.data,
            'timestamp': timezone.now().isoformat()
        })

class SaleViewSet(viewsets.ModelViewSet):
    queryset = Sale.objects.all()
    serializer_class = SaleSerializer
    
    @action(detail=False, methods=['post'])
    def bulk_create(self, request):
        """Create multiple sales from offline queue"""
        sales_data = request.data.get('sales', [])
        created_sales = []
        
        for sale_data in sales_data:
            serializer = self.get_serializer(data=sale_data)
            if serializer.is_valid():
                sale = serializer.save()
                created_sales.append(sale)
        
        return Response({
            'created': len(created_sales),
            'sales': SaleSerializer(created_sales, many=True).data
        })

class CustomerViewSet(viewsets.ModelViewSet):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
```

### Step 5: API URLs

```python
# api_urls.py
from rest_framework.routers import DefaultRouter
from .api_views import BidhaaViewSet, SaleViewSet, CustomerViewSet

router = DefaultRouter()
router.register(r'bidhaas', BidhaaViewSet)
router.register(r'sales', SaleViewSet)
router.register(r'customers', CustomerViewSet)

urlpatterns = router.urls

# In main urls.py, add:
# path('api/', include('your_app.api_urls')),
```

---

## Phase 2: Implement Service Worker (PWA)

### Step 1: Create Service Worker

Create `static/js/service-worker.js`:

```javascript
const CACHE_NAME = 'bidhaa-cache-v1';
const urlsToCache = [
  '/',
  '/static/css/main.css',
  '/static/js/app.js',
  '/static/js/offline.js',
];

// Install Service Worker
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// Fetch Strategy: Network First, then Cache
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
      .then(response => {
        // Clone response and cache it
        const responseClone = response.clone();
        caches.open(CACHE_NAME).then(cache => {
          cache.put(event.request, responseClone);
        });
        return response;
      })
      .catch(() => {
        // If network fails, try cache
        return caches.match(event.request);
      })
  );
});

// Background Sync
self.addEventListener('sync', event => {
  if (event.tag === 'sync-sales') {
    event.waitUntil(syncSales());
  }
});

async function syncSales() {
  // Sync logic will be here
  console.log('Syncing sales data...');
}
```

### Step 2: Register Service Worker

In your base template, add:

```html
<!-- base_template.html -->
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/static/js/service-worker.js')
    .then(registration => {
      console.log('Service Worker registered:', registration);
    })
    .catch(error => {
      console.log('Service Worker registration failed:', error);
    });
}
</script>
```

### Step 3: Create Web App Manifest

Create `static/manifest.json`:

```json
{
  "name": "Bidhaa Management System",
  "short_name": "Bidhaa POS",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#007bff",
  "orientation": "portrait",
  "icons": [
    {
      "src": "/static/images/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/static/images/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

Add to base template:

```html
<link rel="manifest" href="/static/manifest.json">
<meta name="theme-color" content="#007bff">
```

---

## Phase 3: IndexedDB Storage

### Create IndexedDB Manager

Create `static/js/db-manager.js`:

```javascript
class DBManager {
  constructor() {
    this.dbName = 'BidhaaDB';
    this.version = 1;
    this.db = null;
  }

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;

        // Create object stores
        if (!db.objectStoreNames.contains('bidhaas')) {
          const bidhaaStore = db.createObjectStore('bidhaas', { keyPath: 'id' });
          bidhaaStore.createIndex('updated_at', 'updated_at', { unique: false });
        }

        if (!db.objectStoreNames.contains('sales')) {
          const salesStore = db.createObjectStore('sales', { keyPath: 'id', autoIncrement: true });
          salesStore.createIndex('synced', 'synced', { unique: false });
          salesStore.createIndex('created_at', 'created_at', { unique: false });
        }

        if (!db.objectStoreNames.contains('customers')) {
          db.createObjectStore('customers', { keyPath: 'id' });
        }

        if (!db.objectStoreNames.contains('sync_queue')) {
          const syncStore = db.createObjectStore('sync_queue', { keyPath: 'id', autoIncrement: true });
          syncStore.createIndex('type', 'type', { unique: false });
        }
      };
    });
  }

  // Save data to IndexedDB
  async save(storeName, data) {
    const tx = this.db.transaction(storeName, 'readwrite');
    const store = tx.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.put(data);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  // Get all items from store
  async getAll(storeName) {
    const tx = this.db.transaction(storeName, 'readonly');
    const store = tx.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  // Get single item
  async get(storeName, id) {
    const tx = this.db.transaction(storeName, 'readonly');
    const store = tx.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.get(id);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  // Delete item
  async delete(storeName, id) {
    const tx = this.db.transaction(storeName, 'readwrite');
    const store = tx.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.delete(id);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  // Clear all data from store
  async clear(storeName) {
    const tx = this.db.transaction(storeName, 'readwrite');
    const store = tx.objectStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.clear();
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  // Add to sync queue
  async addToSyncQueue(type, data) {
    return this.save('sync_queue', {
      type: type,  // 'sale', 'bidhaa', 'customer'
      data: data,
      timestamp: new Date().toISOString(),
      synced: false
    });
  }

  // Get unsynced items
  async getUnsyncedItems() {
    const tx = this.db.transaction('sync_queue', 'readonly');
    const store = tx.objectStore('sync_queue');
    const index = store.index('synced');
    return new Promise((resolve, reject) => {
      const request = index.getAll(false);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}

// Export instance
const dbManager = new DBManager();
```

---

## Phase 4: Sync Manager

Create `static/js/sync-manager.js`:

```javascript
class SyncManager {
  constructor(dbManager) {
    this.db = dbManager;
    this.apiBase = '/api';
    this.lastSync = localStorage.getItem('lastSync') || null;
    this.syncInProgress = false;
  }

  // Check if online
  isOnline() {
    return navigator.onLine;
  }

  // Download data from server
  async downloadData() {
    if (!this.isOnline()) {
      console.log('Offline: Cannot download data');
      return;
    }

    try {
      // Download bidhaas
      const response = await fetch(`${this.apiBase}/bidhaas/sync/?last_sync=${this.lastSync || ''}`);
      const data = await response.json();
      
      for (const bidhaa of data.data) {
        await this.db.save('bidhaas', bidhaa);
      }

      this.lastSync = data.timestamp;
      localStorage.setItem('lastSync', this.lastSync);
      
      this.showNotification('Data synced successfully', 'success');
    } catch (error) {
      console.error('Download failed:', error);
      this.showNotification('Sync failed', 'error');
    }
  }

  // Upload queued data to server
  async uploadData() {
    if (!this.isOnline() || this.syncInProgress) {
      return;
    }

    this.syncInProgress = true;
    this.updateSyncStatus('Syncing...');

    try {
      const queuedItems = await this.db.getUnsyncedItems();
      
      for (const item of queuedItems) {
        await this.syncItem(item);
      }

      this.showNotification(`${queuedItems.length} items synced`, 'success');
    } catch (error) {
      console.error('Upload failed:', error);
      this.showNotification('Sync failed', 'error');
    } finally {
      this.syncInProgress = false;
      this.updateSyncStatus('');
    }
  }

  async syncItem(item) {
    try {
      let response;
      
      switch (item.type) {
        case 'sale':
          response = await fetch(`${this.apiBase}/sales/`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': this.getCSRFToken()
            },
            body: JSON.stringify(item.data)
          });
          break;
        
        case 'bidhaa':
          response = await fetch(`${this.apiBase}/bidhaas/${item.data.id}/`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': this.getCSRFToken()
            },
            body: JSON.stringify(item.data)
          });
          break;
      }

      if (response.ok) {
        // Mark as synced and delete from queue
        await this.db.delete('sync_queue', item.id);
      }
    } catch (error) {
      console.error(`Failed to sync ${item.type}:`, error);
      throw error;
    }
  }

  // Full sync (download + upload)
  async fullSync() {
    await this.downloadData();
    await this.uploadData();
  }

  // Register sync event listeners
  registerSyncListeners() {
    // Listen for online/offline events
    window.addEventListener('online', () => {
      console.log('Back online!');
      this.showNotification('Connection restored', 'success');
      this.fullSync();
    });

    window.addEventListener('offline', () => {
      console.log('Gone offline');
      this.showNotification('Working offline', 'warning');
    });

    // Periodic sync (every 5 minutes when online)
    setInterval(() => {
      if (this.isOnline() && !this.syncInProgress) {
        this.fullSync();
      }
    }, 5 * 60 * 1000);
  }

  // UI Helpers
  getCSRFToken() {
    return document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';
  }

  updateSyncStatus(message) {
    const statusEl = document.getElementById('sync-status');
    if (statusEl) {
      statusEl.textContent = message;
    }
  }

  showNotification(message, type) {
    // Implement your notification system
    console.log(`[${type}] ${message}`);
  }
}

// Initialize
const syncManager = new SyncManager(dbManager);
```

---

## Phase 5: Offline POS Implementation

Create `static/js/offline-pos.js`:

```javascript
class OfflinePOS {
  constructor(dbManager, syncManager) {
    this.db = dbManager;
    this.sync = syncManager;
    this.cart = [];
  }

  async init() {
    await this.db.init();
    await this.loadProducts();
    this.sync.registerSyncListeners();
    
    // Try to sync on load if online
    if (this.sync.isOnline()) {
      this.sync.fullSync();
    }
  }

  async loadProducts() {
    const bidhaas = await this.db.getAll('bidhaas');
    this.displayProducts(bidhaas);
  }

  displayProducts(bidhaas) {
    const container = document.getElementById('products-container');
    if (!container) return;

    container.innerHTML = bidhaas.map(bidhaa => `
      <div class="product-card" onclick="offlinePOS.addToCart(${bidhaa.id})">
        <img src="${bidhaa.profile_pic || '/static/images/placeholder.png'}" />
        <h4>${bidhaa.jina}</h4>
        <p>${bidhaa.price} TZS</p>
        <small>Stock: ${bidhaa.quantity}</small>
      </div>
    `).join('');
  }

  async addToCart(bidhaaId) {
    const bidhaa = await this.db.get('bidhaas', bidhaaId);
    
    if (!bidhaa) {
      alert('Product not found');
      return;
    }

    if (bidhaa.quantity <= 0) {
      alert('Out of stock');
      return;
    }

    // Check if already in cart
    const existing = this.cart.find(item => item.bidhaa_id === bidhaaId);
    
    if (existing) {
      existing.quantity++;
    } else {
      this.cart.push({
        bidhaa_id: bidhaaId,
        bidhaa: bidhaa,
        quantity: 1,
        unit_price: bidhaa.price
      });
    }

    this.updateCartDisplay();
  }

  updateCartDisplay() {
    const cartEl = document.getElementById('cart-items');
    const totalEl = document.getElementById('cart-total');
    
    if (!cartEl) return;

    const total = this.cart.reduce((sum, item) => 
      sum + (item.quantity * item.unit_price), 0
    );

    cartEl.innerHTML = this.cart.map((item, index) => `
      <div class="cart-item">
        <span>${item.bidhaa.jina}</span>
        <span>${item.quantity} x ${item.unit_price}</span>
        <button onclick="offlinePOS.removeFromCart(${index})">Remove</button>
      </div>
    `).join('');

    totalEl.textContent = total.toFixed(2) + ' TZS';
  }

  removeFromCart(index) {
    this.cart.splice(index, 1);
    this.updateCartDisplay();
  }

  async completeSale() {
    if (this.cart.length === 0) {
      alert('Cart is empty');
      return;
    }

    const sale = {
      sale_number: 'OFFLINE-' + Date.now(),
      customer_name: document.getElementById('customer_name')?.value || '',
      customer_phone: document.getElementById('customer_phone')?.value || '',
      payment_method: document.getElementById('payment_method')?.value || 'cash',
      subtotal: this.cart.reduce((sum, item) => sum + (item.quantity * item.unit_price), 0),
      total_amount: this.cart.reduce((sum, item) => sum + (item.quantity * item.unit_price), 0),
      items: this.cart.map(item => ({
        bidhaa_id: item.bidhaa_id,
        quantity: item.quantity,
        unit_price: item.unit_price
      })),
      status: 'completed',
      sale_date: new Date().toISOString(),
      created_at: new Date().toISOString(),
      synced: false
    };

    try {
      // Save to local database
      await this.db.save('sales', sale);
      
      // Add to sync queue
      await this.db.addToSyncQueue('sale', sale);
      
      // Update stock locally
      for (const item of this.cart) {
        const bidhaa = await this.db.get('bidhaas', item.bidhaa_id);
        bidhaa.quantity -= item.quantity;
        await this.db.save('bidhaas', bidhaa);
        await this.db.addToSyncQueue('bidhaa', bidhaa);
      }

      alert('Sale completed! Will sync when online.');
      this.cart = [];
      this.updateCartDisplay();
      this.loadProducts();

      // Try to sync immediately if online
      if (this.sync.isOnline()) {
        this.sync.uploadData();
      }
    } catch (error) {
      console.error('Failed to save sale:', error);
      alert('Failed to complete sale');
    }
  }
}

// Initialize offline POS
let offlinePOS;
document.addEventListener('DOMContentLoaded', async () => {
  offlinePOS = new OfflinePOS(dbManager, syncManager);
  await offlinePOS.init();
});
```

---

## Usage Instructions

### For Users:

1. **Initial Setup** (with internet):
   - Open the application
   - Login
   - System downloads all data
   - Click "Add to Home Screen" for PWA

2. **Working Offline**:
   - Continue using POS normally
   - All sales saved locally
   - Red indicator shows offline status

3. **Syncing**:
   - When internet returns, click "Sync Now"
   - Or wait for automatic sync
   - Green indicator shows sync complete

### For Developers:

1. **Install dependencies**
2. **Create API endpoints**
3. **Add service worker**
4. **Initialize IndexedDB**
5. **Test offline functionality**

---

## Next Steps

1. Add conflict resolution
2. Implement delta sync (only changed data)
3. Add data compression
4. Create admin dashboard for sync monitoring
5. Add offline analytics

This provides a complete offline-first system similar to Google Drive!